\documentclass{beamer}

\newcommand{\course}{CS 1331 Introduction to Object Oriented Programming}
\newcommand{\lesson}{Object-Oriented Programming, Part 2 of 4}
\newcommand{\code}{http://www.cc.gatech.edu/~simpkins/teaching/gatech/cs1331/code}

\author[Chris Simpkins] 
{Christopher Simpkins \\\texttt{chris.simpkins@gatech.edu}}
\institute[Georgia Tech] % (optional, but mostly needed)

\date[CS 1331]{}
\include{beamer-common}

% \beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}


%------------------------------------------------------------------------
\begin{frame}[fragile]{The {\tt Employee} Class Hierarchy}


Recall our {\tt Employee} class hierarchy:
\vspace{-.1in}
\begin{center}
\includegraphics[height=1.5in]{employee-class-hierarchy.pdf}
\end{center}
\begin{itemize}
\item In the last lecture we made {\tt Employee} abstract and added a polymorphic {\tt monthlyPay} method.
\item Today we'll further refine our class hierarchy by moving duplicated code in {\tt HourlyEmployee} and {\tt SalariedEmployee} into the {\tt Employee} superclass.
\end{itemize}
\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{}


Recall the definition of {\tt disallowZeroesAndNegatives}:
\begin{lstlisting}[language=Java]
private void disallowZeroesAndNegatives(double ... args) {
    boolean shouldThrowException = false;
    String nonPositives = "";
    for (double arg: args) {
        if (arg <= 0.0) {
            shouldThrowException = true;
            nonPositives += arg + " ";
        }
    }
    if (shouldThrowException) {
        String msg = "Following arguments were <= 0: " + nonPositives;
        throw new IllegalArgumentException(msg);
    }
}
\end{lstlisting}

\begin{itemize}
\item This method is duplicated in {\tt HourlyEmployee} and {\tt SalariedEmployee}
\item Let's move the definition of {\tt disallowZeroesAndNegatives} into {\tt Employee} so it will be shared (rather than duplicated) in {\tt SalariedEmployee} and {\tt HourlyEmployee}.
\end{itemize}


\end{frame}
%------------------------------------------------------------------------



%------------------------------------------------------------------------
\begin{frame}[fragile]{Refactoring Common Code Into a Superclass}


After cutting {\tt disallowZeroesAndNegatives} from {\tt SalariedEmployee} and {\tt HourlyEmployee} and pasting it into {\tt Employee}, {\tt javac} tells us:
\vspace{-.1in}
\begin{lstlisting}[language=Java]
$ javac Employee.java HourlyEmployee.java SalariedEmployee.java
HourlyEmployee.java:25: cannot find symbol
symbol  : method disallowZeroesAndNegatives(double,double)
location: class HourlyEmployee
        disallowZeroesAndNegatives(anHourlyWage, aMonthlyHours);
        ^
SalariedEmployee.java:17: cannot find symbol
symbol  : method disallowZeroesAndNegatives(double)
location: class SalariedEmployee
        disallowZeroesAndNegatives(anAnnualSalary);
        ^
2 errors
\end{lstlisting}
% $
\vspace{-.1in}
Why did we get these errors?

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{{\tt protected} Members}


{\tt private} members of a superclass are effectively not inherited by subclasses.  To make a member accessible to subclasses, use {\tt protected}:
\begin{lstlisting}[language=Java]
public abstract class Employee {
    protected void disallowZeroesAndNegatives(double ... args) {
        // ...
    }
    // ...
}
\end{lstlisting}
{\tt protected} members
\begin{itemize}
\item are accessible to subclasses and other classes in the same package, and
\item can be overriden in subclasses.
\end{itemize}
{\tt protected} members provide encapsulation within a class hierarchy, {\tt private} provides encapsulation within a single class.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Fitting Classes Into the Java Hierarchy}


{\tt java.lang.Object} defines several methods that are designed to be overriden in subclasses \href{http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.3.2}{JLS \S 4.3.2}: 
\begin{itemize}
\item The method {\tt equals} defines a notion of object equality, which is based on value, not reference, comparison.
\item The method {\tt hashCode} is very useful, together with the method {\tt equals}, in hashtables such as {\tt java.util.Hashmap}.
\item The method {\tt toString} returns a {\tt String} representation of the object.
\item The method {\tt clone} is used to make a duplicate of an object
\item The method {\tt finalize} is run just before an object is destroyed.
\end{itemize}

A class hierarchy is also sometimes called a {\it framework}.

\end{frame}
%------------------------------------------------------------------------


%------------------------------------------------------------------------
\begin{frame}[fragile]{When to Override the {\tt equals} Method}


The default implementation of {\tt equals} in {\tt java.lang.Object} is object identity - each object {\tt equals} only itself.

When should a class override {\tt equals}?
\begin{itemize}
\item When logical equality differes from object identity, as is the case for {\it value} classes like {\tt Date}
\item When classes don't implement instance control.
  \begin{itemize}
  \item Instance control means that a class ensures that there is only one instance of a class.  
  \end{itemize}
\item When a suitable {\tt equals} method is not provided by a superclass.
\end{itemize}

More important than recognizing {\it when} to override {\tt equals} is knowing {\it how} to override {\tt equals}.
\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{How to Override the {\tt equals} Method}


Obey the general contract of {\tt equals} (\href{}{JLS }), which says that {\tt equals} defines an equivalence relation.  So, for non-null references, {\tt equals} is
\begin{itemize}
\item reflexive - any object {\tt equals} itself
\item symmetric - if {\tt a.equals(b)} is true then {\tt b.equals(a)} must be true
\item transitive - if {\tt a.equals(b)} and {\tt b.equals(c)} are true then {\tt a.equals(c)} must be true
\item consistent - if {\tt a} and {\tt b} do not change between invocations of {\tt a.equals(b)} or {\tt b.equals(a)} then each invocation must return the same result
\item a.equals(null) must always return {\tt false}.
\end{itemize}


\end{frame}
%------------------------------------------------------------------------


%------------------------------------------------------------------------
\begin{frame}[fragile]{A Recipe for Implementing {\tt equals}}


Obeying the general contract of {\tt equals} is easy if you follow these steps.\\

\begin{enumerate}
\item Ensure the other object is not null.
\item Check for reference equality with == (are we comparing to self?).
\item Check that the other object is an {\tt instanceof} this object's class.
\item Cast the other object to this's type (guaranteed to work after. instanceof test)
\item Check that each ``significant'' field in the other object {\tt equals} the corresponding field in this object.
\end{enumerate}



\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{An {\tt equals} Method for {\tt SalariedEmployee}}


First, here's the {\tt equals} method for Employee:
\begin{lstlisting}[language=Java]
public boolean equals(Object other) {
    if (other == null) return false;
    if (this == other) return true;
    if (!(other instanceof Employee)) return false;
    Employee that = (Employee) other;
    return name.equals(that.name) && hireDate.equals(that..hireDate);
}
\end{lstlisting}

Now we can chain it in {\tt SalariedEmployee}:
\begin{lstlisting}[language=Java]
public boolean equals(Object other) {A
    if (other == null) return false;
    if (this == other) return true;
    if (!(other instanceof SalariedEmployee)) return false;
    SalariedEmployee that = (SalariedEmployee) other;
    return super.equals(that) 
        && (this.annualSalary == that.annualSalary);
}
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Overriding versus Overloading}

\vspace{-.05in}
Take another look at {\tt Emplyee}'s {\tt equals} method:
\vspace{-.1in}
\begin{lstlisting}[language=Java]
public boolean equals(Object other) {
    if (other == null) return false;
    if (this == other) return true;
    if (!(other instanceof Employee)) return false;
    Employee that = (Employee) other;
    return name.equals(that.name) && hireDate.equals(that.hireDate);
}
\end{lstlisting}
\vspace{-.1in}
\begin{itemize}
\item The signature of {\tt equals} in {\tt java.lang.Object} is {\tt public boolean equals(Object that)} - the argument is of type {\tt Object}.
\item What if the {\tt equals} in {\tt Employee} took an {\tt Employee} argument instead of an {\tt Object} argument?
\end{itemize}

We'll talk more about this next lecture and extend our {\tt Employee} class hierarchy to overriding (subclass polymorphism) and overloading (ad-hoc polymorphism).\footnote{There's actually much more to properly overriding {\tt equals}, like overriding {\tt hashCode}.  We'll revisit {\tt equals} and {\tt hashCode} when we learn about collections.}
\end{frame}
%------------------------------------------------------------------------


% %------------------------------------------------------------------------
% \begin{frame}[fragile]{}


% \begin{lstlisting}[language=Java]

% \end{lstlisting}

% \begin{itemize}
% \item
% \end{itemize}


% \end{frame}
% %------------------------------------------------------------------------


\end{document}
