\documentclass{beamer}

\newcommand{\course}{CS 1331 Introduction to Object Oriented Programming}
\newcommand{\lesson}{Classes}
\newcommand{\code}{http://www.cc.gatech.edu/~simpkins/teaching/gatech/cs1331/code}

\author[Chris Simpkins] 
{Christopher Simpkins \\\texttt{chris.simpkins@gatech.edu}}
\institute[Georgia Tech] % (optional, but mostly needed)

\date[CS 1331]{}
\subject{\lesson}
% This is only inserted into the PDF information catalog. Can be left
% out. 

% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[width=0.6in]{coc-logo}{cc_2012_logo}
% \logo{\pgfuseimage{coc-logo}}

\mode<presentation>
{
  \usetheme{Berlin}
  \useoutertheme{infolines}

  % or ...

 \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{listings}
\usepackage[abbr]{harvard}

\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


\usepackage{listings}
 
% "define" Scala
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]""",
}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
 
% Default settings for code listings
\lstset{frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\scriptsize\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  keepspaces=true
  %tabsize=3
}


\title[\course] % (optional, use only with long
                                      % paper titles)
{\lesson}

\subtitle{}
%% {Include Only If Paper Has a Subtitle}


% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
%% \AtBeginSection[]
%% {
%%   \begin{frame}<beamer>{Outline}

%%  \tableofcontents[currentsection]
%%   \end{frame}
%% }

% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

% \beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}


%------------------------------------------------------------------------
\begin{frame}[fragile]{The Anatomy of a Class Definition}

\vspace{-.1in}
\begin{columns}[t]
\begin{column}{6.5cm}
{\tt Card.java}
\begin{lstlisting}[language=Java]
import java.util.Arrays;

public class Card {
  
  public static final String[] VALID_RANKS = {"2", ... , "ace"};
  public static final String[] VALID_SUITS = {"diamonds", ... };
  private String rank;
  private String suit;

  public Card(String aRank, String aSuit) {
    // ...
  }
  public String toString() {
    return rank + " of " + suit;
  }
  private boolean isValidRank(String someRank) {
    // ...
  }
}
\end{lstlisting}
\end{column}

\begin{column}{5.5cm}
A class definition file contains
\vspace{.06in}
\begin{itemize}
\item import statements
\vspace{.05in}
\item class declaration
\vspace{.04in}
\item static variable definitions
\vspace{.26in}
\item instance variable definitions
\vspace{.03in}
\item constructor
\vspace{.25in}
\item public methods
\vspace{.23in}
\item private helper methods
\end{itemize}
\end{column}
\end{columns}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{A Card Class, v0}



Consider how to represent a Card ADT:
\begin{itemize}
\item rank - the rank of a playing card, e.g., 2, jack, ace
\item suit - the suit of a playing card, e.g., spades, diamonds
\end{itemize}
\vspace{-.1in}
\begin{lstlisting}[language=Java]
public class Card0 {

    String rank;
    String suit;

    public static void main(String[] args) {
        Card0 c = new Card0();
        System.out.println(c);
    }
}
\end{lstlisting}
\vspace{-.1in}
\begin{itemize}
\item {\tt rank} and {\tt suit} are instance variables
\item Every {\it instance} of {\tt Card0} has its own copy of instance variables.
\end{itemize}


Note that we can put a {\tt main} method in any class. This is useful for exporatory testing, like we're doing here.

The String representation isn't very appealing.  (What does it print?)

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Card Class, v1}

\vspace{-.1in}
\begin{lstlisting}[language=Java]
public class Card1 {

    String rank;
    String suit;

    public String toString() {
        return rank + " of " + suit;
    }
    public static void main(String[] args) {
        Card1 swedishPop = new Card1();
        swedishPop.rank = "ace";
        swedishPop.suit = "base";
        Card1 handy = new Card1();
        handy.rank = "jack";
        handy.suit = "all trades";
        System.out.println(swedishPop);
        System.out.println(handy);
    }
}
\end{lstlisting}
\vspace{-.1in}
Now we have an ``ace of base'' card and a ``jack of all trades'' card.  But those aren't valid cards.


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Encapsulation: Card, v2}


Now we're protecting the instance variables by making them private:
\begin{lstlisting}[language=Java]
public class Card2 {

    private String rank;
    private String suit;

    public String toString() {
        return rank + " of " + suit;
    }

    public static void main(String[] args) {
        Card2 c = new Card2();
        c.rank = "ace";
        c.suit = "base";
        System.out.println(c);
    }
}
\end{lstlisting}

Why does this still compile?

\begin{itemize}
\item {\tt main} method still part of {\tt Card2} - has access to private parts
\end{itemize}
Let's make a dealer class.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{A Dealer Class}


A Dealer class:
\begin{lstlisting}[language=Java]
public class Dealer {

    public static void main(String[] args) {
        Card2 c = new Card2();
        c.rank = "ace";
        c.suit = "base";
        System.out.println(c);
    }
}
\end{lstlisting}

This won't compile.  Why?

\begin{itemize}
\item {\tt rank} and {\tt suit} are {\tt private} in {\tt Card2}
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Mutators: Card, v3}

\begin{lstlisting}[language=Java]
public class Card3 {

    private String rank;
    private String suit;

    public String toString() {
        return rank + " of " + suit;
    }

    public void setRank(String rank) {
        rank = rank;
    }

    public void setSuit(String suit) {
        suit = suit;
    }
}
\end{lstlisting}

{\tt setX} is the Java convention for a setter method for an instance variable named {\tt x}.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Dealing {\tt Card3}}


\begin{lstlisting}[language=Java]
public class Dealer3 {

    public static void main(String[] args) {
        Card3 c = new Card3();
        c.setRank("ace");
        c.setSuit("base");
        System.out.println(c);
    }
}
\end{lstlisting}

Prints ``null of null''.  What happened?


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Shadowing Variables}


The parameters in the setters ``shadowed'' the instance variables:
\begin{lstlisting}[language=Java]
public void setRank(String rank) {
    rank = rank;
}

public void setSuit(String suit) {
    suit = suit;
}
\end{lstlisting}

\begin{itemize}
\item {\tt rank} in {\tt setRank} refers to the local {\tt rank} variable, not the instance variable of the same name
\item {\tt suit} in {\tt setSuit} refers to the local {\tt suit} variable, not the instance variable of the same name
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Dealing with {\tt this}: Card, v4}

\begin{lstlisting}[language=Java]
public class Card4 {

    private String rank;
    private String suit;

    public String toString() {
        return rank + " of " + suit;
    }

    public void setRank(String rank) {
        this.rank = rank;
    }

    public void setSuit(String suit) {
        this.suit = suit;
    }
}
\end{lstlisting}

We can still set invalid ranks and suits.  How to fix?


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Class Invariants}


Class invariant: a condition that must hold for all instances of a class in order for for instances of the class to be considered valid.\\
\vspace{.1in}
Invariants for Card class:
\begin{itemize}
\item {\tt rank} must be one of \{{\tt "2", "3", "4", "5", "6", "7", "8", "9",
         "10", "jack", "queen", "king", "ace"}\}
\item {\tt suit} must be one of \{{\tt "diamonds", "clubs", "hearts","spades"}\}
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Maintaining Class Invariants via Input Validation}



{\tt rank} invariant can be maintained with:
\vspace{-.1in}
\begin{lstlisting}[language=Java]
import java.util.Arrays;
// ...
public class Card5 {

    private final String[] VALID_RANKS =
        {"2", "3", "4", "5", "6", "7", "8", "9",
         "10", "jack", "queen", "king", "ace"};

    public void setRank(String rank) {
        if (!isValidRank(rank)) {
            System.out.println(rank + " is not a valid rank.");
            System.exit(0);
        }
        this.rank = rank;
    }

    private boolean isValidRank(String someRank) {
        return Arrays.asList(VALID_RANKS).contains(someRank);
    }
    // ...
}
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Class Invariants Ensure Consistent Objects}


Now we can't write code that instantiates an invalid {\tt Card5} object:
\begin{lstlisting}[language=Java]
public class Dealer5 {

    public static void main(String[] args) {
        Card5 c = new Card5();
        c.setRank("ace");
        c.setSuit("base");
        System.out.println(c);
    }
}
\end{lstlisting}
yields:
\begin{lstlisting}[language=bash]
$ java Dealer5
base is not a valid suit.
\end{lstlisting}
%$ - get Emacs to stop displaying stuff below in pink

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Classes and Objects}


With {\tt Card5} we are now protected from code like:
\vspace{-.1in}
\begin{lstlisting}[language=Java]
public class Dealer5 {

    public static void main(String[] args) {
        Card5 c = new Card5();
        c.setRank("ace");
        c.setSuit("base");
        System.out.println(c);
    }
}
\end{lstlisting}

But what if we printed our {\tt Card} instance, {\tt c}, before we called the setters?
\vspace{-.1in}
\begin{lstlisting}[language=Java]
public class Dealer5 {

    public static void main(String[] args) {
        Card5 c = new Card5();
        System.out.println(c);
        c.setRank("ace");
        c.setSuit("base");
        System.out.println(c);
    }
}
\end{lstlisting}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Initializing Objects}


In general, it's poor style to require multi-step initialization.
\begin{itemize}
\item After {\tt new Card()} is called, instance variables have useless defaults.
\item Client programmer must remember to call setter methods.
\item Often there can be order dependencies that we don't want to burden client programmers with.
\end{itemize}
The way to fix this is by using constructors.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Constructors}


Constructors initialize instances (objects) of a class:
\begin{lstlisting}[language=Java]
public class Card6 {
    // ...
    public Card6(String rank, String suit) {
        setRank(rank);
        setSuit(suit);
    }
    // ...
}
\end{lstlisting}

Constructors provide a nicer way to initilize objects:
\begin{lstlisting}[language=Java]
public class Dealer6 {

    public static void main(String[] args) {
        Card6 c = new Card6("queen", "hearts");
        System.out.println(c);
    }
}
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Static Members}


Do we need a separate instance of {\tt VALID\_RANKS} and {\tt VALID\_SUITS} for each instance of our Card class?

{\tt static} members are shared with all instances of a class:
\begin{lstlisting}[language=Java]
public static final String[] validRanks = 
    {"2", "3", "4", "5", "6", "7", "8", "9",
     "10", "jack", "queen", "king", "ace"};
public static final String[] validSuits =
    {"diamonds", "clubs", "hearts","spades"};
\end{lstlisting}
Given the declarations above:
\begin{itemize}
\item Each instance shares a single instance of {\tt VALID\_RANKS} and a single instance of {\tt VALID\_SUITS}
\item Since they're {\tt final}, we can make them {\tt public} so clients of our Card class can see them
\end{itemize}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Immutable Objects}


Card objects don't change.  We can model this behavior by removing the setters and putting the initialization code in the constructor:
\vspace{-.1in}
\begin{lstlisting}[language=Java]
public Card(String aRank, String aSuit) {
  String theRank = normalizeString(aRank);
  String theSuit = normalizeString(aSuit);
  if (isValidRank(theRank)) {
      rank = theRank;
  } else {
      String msg = "Illegal rank: " + theRank;
      throw new IllegalArgumentException(msg);
  }
  if (isValidSuit(theSuit)) {
      suit = theSuit;
  } else {
      String msg = "Illegal suit: " + theSuit;
      throw new IllegalArgumentException(msg);
  }
}
\end{lstlisting}
\vspace{-.1in}
\small Note the use of another idiom for disambiguating constructor paramters from instance variables (as opposed to using {\tt this}).\normalsize

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Multiple Constructors}


Suppose we wanted to provide client programmers with a convenient way to initialze {\tt Card}s using strings like ``ace of spades''.\\
\vspace{.1in}
We can provide another constructor:

\begin{lstlisting}[language=Java]
public Card(String aCardDescription) {
  // This is the syntax for calling another constructor
  this(extractRank(aCardDescription), extractSuit(aCardDescription));
}

public Card(String aRank, String aSuit) {
  // ...
}
\end{lstlisting}

The constructors above are ``chained'' so we don't duplicate code.

\end{frame}
%------------------------------------------------------------------------


% %------------------------------------------------------------------------
% \begin{frame}[fragile]{}


% \begin{lstlisting}[language=Java]

% \end{lstlisting}

% \begin{itemize}
% \item
% \end{itemize}


% \end{frame}
% %------------------------------------------------------------------------


\end{document}
