\documentclass{beamer}

\newcommand{\course}{CS 1331 Introduction to Object Oriented Programming}
\newcommand{\lesson}{Arrays, Part 2 of 2}
\newcommand{\code}{http://www.cc.gatech.edu/~simpkins/teaching/gatech/cs1331/code}

\author[Chris Simpkins] 
{Christopher Simpkins \\\texttt{chris.simpkins@gatech.edu}}
\institute[Georgia Tech] % (optional, but mostly needed)

\date[CS 1331]{}

\usepackage{colortbl}

\include{beamer-common}

% \beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}


%------------------------------------------------------------------------
\begin{frame}[fragile]{Arrays are First-Class Objects}


We've seen that
\begin{itemize}
\item arrays are objects, so array variables are references,
\item arrays can be stored in variables, passed as arguments, and returned from methods.
\end{itemize}

This means that we must take the same precautions when dealing with array references as when dealing with references of Class types.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Array References}


Look at  \link{\code/MyYears.java}{MyYears.java}. Note that the getter method returns the private instance variable {\tt years}:
\begin{lstlisting}[language=Java]
public int[] getYears() {
    return years;
}
\end{lstlisting}

Client code cannot change the object that {\tt year} points to, but can change elements of {\tt year}.  Consider:
\begin{lstlisting}[language=Java]
private void modifyElement(int[] array, int index, int newValue) {
    array[index] = newValue;
}
\end{lstlisting}
This method will change the element value at {\tt index} in any array you pass to it, including the private {\tt years} reference returned from {\tt getYears}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Privacy Leaks with Array Instance Variables}


A getter method that returns a reference to a private array instance variable can ``leak'' private data just like an accessor that returns a reference to a private instance variable of Class type.\\
\vspace{.1in}
Given the accessor {\tt getYears} and the utility helper function {\tt modifyElement}, we can violate encapsulation in the {\tt MyYears}:
\begin{lstlisting}[language=Java]
MyYears my = new MyYears();
int[] a = my.getYears();
my.modifyElement(a, 2, 2013);
// The modifyElement method demonstrates array parameters,
// but the following line does the same thing and is clearer.
a[2] = 2013; 
\end{lstlisting}

The code above modifies the {\tt my} object's {\tt years} instance variable!  How to fix?

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Fixing Privacy Leaks}


The way to fix privacy leaks like this is to return deep copies of instance variables in getter methods.  {\tt MyYears} already has the helper method to provide this functionality.  A safer {\tt getYears} method would be:
\begin{lstlisting}[language=Java]
public int[] getYears() {
    return copyOf(years);
}
\end{lstlisting}

With this definition of {\tt getYears} client code can't modify the private data held in the {\tt years} instance variable of {\tt MyYears} objects becuase clients don't get a reference to the instance variable, they get a reference to a (snapshot) copy of it.


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Partially Filled Arrays}


Say we want the speedy acces of an array, with the flixiblity of a dynamically-allocated data structure.

\begin{lstlisting}[language=Java]
public class PartialIntArray {

    private int[] elementData;
    private int size;

    public PartialIntArray(int initialCapacity) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        this.elementData = new int[initialCapacity];
    }

    public PartialIntArray() {
        this(10);
    }

    // ...
}
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Adding Elements to PartialIntArray}


Assuming we don't need to automatically ``grow'' our array-backed data structure when needed (like {\tt java.util.ArrayList} does), we can add elements like this:

\begin{lstlisting}[language=Java]
public class PartialIntArray {

  // ...

    public void add(int e) {
        elementData[size++] = e;
    }

}
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Accessing Elements of PartialIntArray}


We can provide access to elements of our PartialIntArray with:

\begin{lstlisting}[language=Java]
public class PartialIntArray {
    // ...
    
    public int get(int index) {
        return elementData[index];
    }
}
\end{lstlisting}

Note that we're providing access to individual elements, not the entire underlying array.  The underlying array is an implementation detail.
\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Traversing a PartialIntArray}


To allow clients of {\tt PartialIntArray} to traverse its elements, we need one more method in our API - size:
\begin{lstlisting}[language=Java]
public class PartialIntArray {
    // ...

    public int size() {
        return this.size;
    }
}
\end{lstlisting}
Now we can add elements to a {\tt PartialIntArray} and traverse it in a similar manner to regular arrays:

\begin{lstlisting}[language=Java]
PartialIntArray pia = new PartialIntArray();
pia.add(1);
// add more ...
for (int i = 0; i < pia.size(); ++i) {
    System.out.println(pia.get(i));
}
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Encapsulation and Information Hiding}


Our {\tt PartialIntArray} class demonstrates two important concepts in software engineering: encapsulation and information hiding.

\begin{itemize}
\item The {\tt elementData} instance variable was private and never exposed in its entirety to clients.
\item All access to {\tt elementData} was provided through instance methods, so we can ensure data consistency by enforcing invariants, validating input, etc.
\item We could have called our class {\tt RandomAccessIntList}, because the fact that an array was used is an implementation detail.  Client code need not be aware of implementation details (to an extent ...).
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{{\tt PartialIntArray} and {\tt java.util.ArrayList}}


Our {\tt PartialIntArray} example was inspired by Java's standard ArrayList class.  Try these exercises at home:
\begin{itemize}
\item Consider what happens if a user of {\tt PartialIntArray} supplies an out of bounds index to {\tt get}, i.e., $< 0$ or $\ge$ {\tt size}.  Is this desirable?  If not, how would you improve it?
\item Add a {\tt remove(int index)} method that removes the element at {\tt index}.
\item Look at the source for {\tt java.util.ArrayList}.
\begin{itemize}
\item Oracle has made it a bit less straightforward to get the std lib source, so I put up a copy here: \url{http://simpkins.org/java-lib-src/}
\item Note that the directory layout for a Java library matches the package structure.  So you'll find {\tt ArrayList.java} in {\tt java/util/}.
\end{itemize}
\end{itemize}

As in any craft, study the work of masters to improve your own skillz.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Variable Arity Parameters}


\begin{itemize}
\item The {\it arity} of a method is its number of formal parameters.
\item So far, all the methods we've written have fixed arity.
\item The last parameter to a method may be a {\it variable arity parameter}, a.k.a. {\it var args} parameter (\href{http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.1}{JLS \S 8.4.1}), whose syntax is simply to add an ellipse ({\tt ...}) after the type name.
\item The var args parameter is accessed as an array inside the method.
\end{itemize}
For example:
\begin{lstlisting}[language=Java]
public static int max(int ... numbers) {
    int max = numbers[0];
    for (int i = 1; i < numbers.length; ++i) {
        if (numbers[i] > max) max = number;
    }
    return max;
}
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Multidimensional Arrays}


You can create arrays of any number of dimensions simply by adding additional square-bracketed sizes.  For example:

\begin{lstlisting}[language=Java]
char[][] grid;
\end{lstlisting}
The declaration statement above:
\begin{itemize}
\item Declares a 2-dimensional array of  {\tt char}.
\item As with one-dimensinal arrays, {\tt char} is the base type.
\item Each element of {\tt grid}, which is indexed by two {\tt int} expressions, is a {\tt char} variable.
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Initializing Multidimensional Arrays}


Initialization of 2-dimensional arrays can be done with {\tt new}:
\begin{lstlisting}[language=Java]
grid = new char[10][10];
\end{lstlisting}

or with literal initialization syntax:
\begin{lstlisting}[language=Java]
char[][] grid = {{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
                 {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},
                 {' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', ' '},
                 {' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', ' '},
                 {' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' '},
                 {' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' '},
                 {' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' '},
                 {' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' '},
                 {' ', ' ', ' ', '*', '*', '*', '*', ' ', ' ', ' '},
                 {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}};
\end{lstlisting}

Notice that a 2-dimensional array is an array of 1-dimensional arrays (and a 3-dimensional array is an array of 2-dimensional arrays, and so on).

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Visualizing Multidimensional Arrays}


Our 2-dimensional {\tt grid} array can be visualized as a 2-d grid of cells.\\
\vspace{.1in}
\begin{tabular}{p{.4in}p{.2in}p{.2in}p{.2in}p{.2in}p{.2in}p{.2in}p{.2in}p{.2in}p{.2in}p{.2in}}
         & [0] & [1] & [2] & [3] & [4] & [5] & [6] & [7] & [8] & [9]
\end{tabular}
\begin{tabular}{p{.4in}|p{.2in}|p{.2in}|p{.2in}|p{.2in}|p{.2in}|p{.2in}|p{.2in}|p{.2in}|p{.2in}|p{.2in}|}\cline{2-11}
grid[0] & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' \\
\cline{2-11}
grid[1] & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' \\
\cline{2-11}
grid[2] & ' ' & '*' & '*' & ' ' & ' ' & ' ' & ' ' & '*' & '*' & ' ' \\
\cline{2-11}
grid[3] & ' ' & '*' & \cellcolor{yellow}'*' & ' ' & ' ' & ' ' & ' ' & '*' & '*' & ' ' \\
\cline{2-11}
grid[4] & ' ' & ' ' & ' ' & ' ' & '*' & '*' & ' ' & ' ' & ' ' & ' ' \\
\cline{2-11}
grid[5] & ' ' & ' ' & ' ' & ' ' & '*' & '*' & ' ' & ' ' & ' ' & ' ' \\
\cline{2-11}
grid[6] & ' ' & '*' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & '*' & ' ' \\
\cline{2-11}
grid[7] & ' ' & ' ' & '*' & ' ' & ' ' & ' ' & ' ' & '*' & ' ' & ' ' \\
\cline{2-11}
grid[8] & ' ' & ' ' & ' ' & '*' & '*' & '*' & '*' & ' ' & ' ' & ' ' \\
\cline{2-11}
grid[9] & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' & ' ' \\
\cline{2-11}
\end{tabular}\\
\vspace{.1in}
And an individual cell can be accessed by supplying two indices:

\begin{lstlisting}[language=Java]
grid[3][2] == '*'; // true
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Traversing Multidimensional Arrays}


Traverse 2-dimensional array by nesting loops.  The key to getting it right is to use the right {\tt length}s.
\begin{lstlisting}[language=Java]
for (int row = 0; row < grid.length; ++row) {
    for (int col = 0; col < grid[row].length; ++col) {
        System.out.print(grid[row][col]);
    }
    System.out.println();
}
\end{lstlisting}
Note that the for loops above traverse the grid in row-major order.  We can traverse the grid in column-major order by reversing the nesting of the for-loops:
\begin{lstlisting}[language=Java]
for (int col = 0; col < grid[0].length; ++col) {
    for (int row = 0; row < grid.length; ++row) {
        System.out.print(grid[row][col]);
    }
    System.out.println();
}
\end{lstlisting}


\end{frame}
%------------------------------------------------------------------------


%------------------------------------------------------------------------
\begin{frame}[fragile]{Ragged Arrays}


It's possible to create {\it ragged arrays} by creating nested arrays of variable length.  For example:
\begin{lstlisting}[language=Java]
double [][] ragged = new double[3][];
ragged[0] = new double[5];
ragged[1] = new double[10];
ragged[2] = new double[4];
\end{lstlisting}

Can we traverse array {\tt ragged} in row-major order?

Can we traverse array {\tt ragged} in column-major order?

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Programming Exercise}

\begin{itemize}
\item Download \link{\code/array-data.csv}{array-data.csv}.
\item Let's write a program to read the data from \link{\code/array-data.csv}{array-data.csv} into an array.
\end{itemize}

\end{frame}
%------------------------------------------------------------------------


% %------------------------------------------------------------------------
% \begin{frame}[fragile]{}


% \begin{lstlisting}[language=Java]

% \end{lstlisting}

% \begin{itemize}
% \item
% \end{itemize}


% \end{frame}
% %------------------------------------------------------------------------


\end{document}
