\documentclass{beamer}

\newcommand{\course}{CS 1331 Introduction to Object Oriented Programming}
\newcommand{\lesson}{Conditional Execution}
\newcommand{\code}{http://www.cc.gatech.edu/~simpkins/teaching/gatech/cs1331/code}

\author[Chris Simpkins] 
{Christopher Simpkins \\\texttt{chris.simpkins@gatech.edu}}
\institute[Georgia Tech] % (optional, but mostly needed)

\date[CS 1331]{}
\subject{\lesson}
% This is only inserted into the PDF information catalog. Can be left
% out. 

% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[width=0.6in]{coc-logo}{cc_2012_logo}
% \logo{\pgfuseimage{coc-logo}}

\mode<presentation>
{
  \usetheme{Berlin}
  \useoutertheme{infolines}

  % or ...

 \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{listings}
\usepackage[abbr]{harvard}

\usepackage[english]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


\usepackage{listings}
 
% "define" Scala
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]""",
}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
 
% Default settings for code listings
\lstset{frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\scriptsize\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  keepspaces=true
  %tabsize=3
}


\title[\course] % (optional, use only with long
                                      % paper titles)
{\lesson}

\subtitle{}
%% {Include Only If Paper Has a Subtitle}


% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
%% \AtBeginSection[]
%% {
%%   \begin{frame}<beamer>{Outline}

%%  \tableofcontents[currentsection]
%%   \end{frame}
%% }

% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

% \beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

%------------------------------------------------------------------------
\begin{frame}{Structured Programming}


Control flow issues:
\begin{itemize}
\item Multiple vs. single entry
\item Multiple vs. single exit
\item {\tt goto} considered harmful
\end{itemize}

Structured programming: block structure, single entry, single exit, no {\tt goto}.  All algorithms expressed by:
\begin{itemize}
\item Sequence - one statement after another
\item Selection - conditional execution (not conditional jumping)
\item Iteration - loops
\end{itemize}

Today we'll learn Java's support for conditoinal execution\footnote{I
  don't like the book's term ``branching.''  Branching is not
  structured programming.  Branching is how you write ``spaghetti code.''}.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{The {\tt if-else} Statement}


Conditional execution:
\begin{lstlisting}[language=Java]
if (booleanExpression)
    // a single statement executed when {\tt true}
else
    // a single statement executed when {\tt false}
\end{lstlisting}
\vspace{-.1in}
\begin{itemize}
\item {\tt booleanExpression} must be enclosed in parentheses
\item {\tt else} not required
\end{itemize}
\vspace{-.1in}
Example:
\begin{lstlisting}[language=Java]
if ((num % 2) == 0)
    System.out.printf("%d is even.%n", num);
else
    System.out.printf("%d is odd.%n", num);
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Ternary If-Else Expression}


The ordinary {\tt if-else} control structure is a statement, leading
to conditional assignment code like this: 
\begin{lstlisting}[language=Java]
String dinner = null;
if (temp > 60) {
    dinner = "grilled";
} else {
    dinner = "baked";
}
\end{lstlisting}

The ternary operator combines the above into one expression (recall
that expressions have values):

\begin{lstlisting}[language=Java]
String dinner = (temp > 60) ? "grilled" : "baked" 
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------


%------------------------------------------------------------------------
\begin{frame}[fragile]{Blocks}


Java is block-structured.  You can enclose any number
of statements in curly braces (\{ ... \}) to create a block.  Blocks
are like single statements (not expressions - they don't have values).
\begin{lstlisting}[language=Java]
if ((num % 2) == 0) {
    System.out.printf("%d is even.%n", num);
    System.out.println("I like even numbers.");
} else {
    System.out.printf("%d is odd.%n", num);
    System.out.println("I'm ambivalent about odd numbers.");
}
\end{lstlisting}
The Java conventions recommend using braces always, even for single
statements.  A very common error is adding statements to an if-branch
and forgetting to add braces.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Multiway {\tt if-else} Statements}


This is hard to folllow:
\begin{lstlisting}[language=Java]
if (color.toUpperCase().equals("RED")) {
    System.out.println("Redrum!");
} else {
    if (color.toLowerCase().equals("yellow")) {
        System.out.println("Submarine");
    } else {
        System.out.println("I got nuthin.");
    }
}
\end{lstlisting}
\vspace{-.1in}
This multiway {\tt if-else} is equivalent, and clearer:
\vspace{-.1in}
\begin{lstlisting}[language=Java]
if (color.toUpperCase().equals("RED")) {
    System.out.println("Redrum!");
} else if (color.toLowerCase().equals("yellow")) {
    System.out.println("Submarine");
} else {
    System.out.println("I got nuthin.");
}
\end{lstlisting}

Play with \href{\code/Conditionals.java}{Conditionals.java}.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{The {\tt switch} Statement}


Java provides {\tt switch} statement for multi-way branching.
\vspace{-.1in}
\begin{lstlisting}[language=Java]
switch (expr) {
    case 1:
        // executed only when case 1 holds
        break;
    case 2:
        // executed only when case 2 holds
    case 3:
        // executed whenever case 2 and 3 hold
        break;
    default:
        // executed only when other cases don't hold        
}
\end{lstlisting}
\vspace{-.15in}
\begin{itemize}
\item Type of {\tt expr} can be {\tt char}, {\tt int}, {\tt short}, {\tt byte}, or {\tt String}
\item In example above, what is type of {\tt expr}?
\item {\tt switch} considered harmful.  97\% of fall-throughs
  unwanted\footnote{Peter van der Linden, {\it Deep C Secrets}}
\item Anachronism from ``structured assembly language'', a.k.a. C (a {\tt switch} is just a jump table)
\end{itemize}

Play with \href{\code/Switch.java}{Switch.java}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Boolean Expressions}


Simple boolean expressions formed with comparison operators:
\begin{itemize}
\item Equal to: {\tt ==}, like $=$ in math
  \begin{itemize}
    \item Remember, {\tt =} is assignment operator, {\tt ==} is comparison operator!
  \end{itemize}
\item Not equal to: {\tt !=}, like $\ne$ in math
\item Greater than: {\tt >}, like $>$ in math
\item Greater than or equal to: {\tt >=}, like $\ge$ in math
\item ...
\end{itemize}
Examples:
\begin{lstlisting}[language=Java]
1 == 1 // true
1 != 1 // false
1 >= 1 // true
1 > 1  // false
\end{lstlisting}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Combining Boolean Expressions}


Simple boolean expressions can be combined to form larger expressions using:
\begin{itemize}
\item And: {\tt \&\&}, like $\land$ in math
\item Or: {\tt ||}, like $\lor$ in math
\end{itemize}
Examples:
\begin{lstlisting}[language=Java]
if ((kids !=0) && ((pieces / kids) >= 2))
    System.out.println("Each kid may have two pieces.");
\end{lstlisting}
In this example, note that Java uses short-circuit evaluation.  If
{\tt kids !=0} evaluates to {\tt false}, then the second sub-expression is not evaluated, thus avoiding a divide-by-zero error.

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Precedence and Associativity}


If an expression contains no parentheses, Java evaluates using precedence and associativity rules (Page 126 in your textbook) in a three-step process:
\begin{enumerate}
\item Associated operands with operators, starting with highest-precedence operators.  This step effectively parenthesizes expression (book calls this ``binding'')
\item Evaluate subexpressions in left to right order (possibly in multiple sweeps if deeply nested)
\item Evaluate outer ``top-level'' operation once all subexpressions have been evaluated
\end{enumerate}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Evaluation Examples}


The expression {\tt 6 + 7 * n - 12} is evaluated in the following steps, assuming n = 2:
\begin{lstlisting}[language=Java]
((6 + (7 * n)) - 12)
((6 + (7 * 2)) - 12)
((6 + 14) - 12)
(20 - 12)
8
\end{lstlisting}
\vspace{-.1in}
Beware of side-effects.  The expression {\tt ((result = (++n)) + (other = (2*(++n))))} is evaluated as follows:
\begin{lstlisting}[language=Java]
((result = (++n)) + (other = (2*(++n))))
((result = 3) + (other = (2*(++n))))
(3 + (other = (2*(++n))))
(3 + (other = (2*4))) // Note that n was 3 from the first pre-increment
(3 + (other = 8))
(3 + 8)
11
\end{lstlisting}
\vspace{-.1in}
Three side-effects: result = 3, other = 8, and n = 4

\end{frame}
%------------------------------------------------------------------------


% %------------------------------------------------------------------------
% \begin{frame}[fragile]{}


% \begin{lstlisting}[language=Java]

% \end{lstlisting}


% \end{frame}
% %------------------------------------------------------------------------


\end{document}
